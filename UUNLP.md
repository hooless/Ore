# Understading Unix/Linux Programming

## 1.3.1 系统资源
- 处理器（processor）
- 内存 （Memory)
- 输入输出 （I/O)
- 进程管理 （Process Management)
- 计时器（Timers)
- 进程间通信（Interprocess Communication )
- 设备（Device)
- 网络（Networking）进程间通信的特殊形式，通过网络，不同主机上的进程也可以通信。

## 1.4.2 登陆-运行程序-注销
- 在登陆过程中，当用户名和密码通过验证后，系统启动一个叫 shell 的进程，然后把用户交给 shell ，由 shell 处理请求。每个用户都有自己的 shell 进程。 


## 1.4.4 文件的操作
- 文件是数据的集合。 
- 文件中的数据是如何存储在磁盘上的?
- 文件是如何被复制的？
- 文件如何移动和改名的，以及问的名字存放在哪？

## 1.5.2 网络桥牌展示 Unix 系统编程中 3 个重要的方面
- 通信 
```
某个用户或进程如何与其他用户或进程交换信息
```
- 协作
```
同一时刻，网络桥牌的两个用户不会都去拿同一个桥牌，程序如何来协调多个进程使得资源共享不会冲突
```
- 网络访问
```
相互独立的计算机通过网络连接到一起，计算机是如何使用网络
```

## 2.5.2 使用 open、read、close
- open 
```
int fd = open(char * path , int flag)
系统调用，在进程和文件之间建立一条连接，这个连接被称为文件描述符，它就像一条有进程通向内核的管道。
如果文件被顺利打开，内核返回一个正整数的值，这个值就是文件描述符，用来唯一标记这个连接，具有唯一性，必须通过文件描述符对文件进行操作。
```
- read  
```
ssize_t numread  = read(int fd, void *buf, size_t nbyte);
系统调用，请求用内核从 fd 指定的文件中读取 nbyte 字节的数据，存放在 buf 所指定的内存空间中，内核如果成功的读取了数据，返回所读字节数目，否则返回 -1 。
```
- close 
```
int result = close(int fd)
系统调用，关闭进程和文件之间的连接，成功返回0 ，失败返回 -1 。 
```

## 2.5.5 Unix 存储时间的方式
- time_t 数据结构
```
Unix 中时间是用一个整数来表示的，它的数值是从 1970 年 1 月 日 0 时开始经过的秒数。
在头文件 time.h 中： typedef long int time_t;
```
- ctime  将 time_t 显示出来
```
char * ctime(const time_t * timep)
```


### 2.6.2 写文件
- write 系统调用
```
调用 write 后必须检查返回值是否与要写入的相同，如果不同，就要采取响应的措施。
```
问题：如果不同，为什么不是写入失败？

### 2.7.2 系统调用耗时
- 使用缓冲区，减少系统调用
```
系统调用开销大，不仅仅因为要传输数据，当运行内核代码时，CPU 工作在超级用户模式，这对应一些特殊的堆栈和内存环境，必须在系统调用时建立好。系统调用结束后，CPU 要切换到用户模式，必须把堆栈和内存环境恢复成用户模式运行时的状态，这种运行环境的切换要消耗很多时间。
```

### 2.8 内核缓冲技术
```
管理员模式和用户模式之间的切换需要消耗时间，相比之下，磁盘的IO操作消耗的时间更多，为了提高效率，内核也要使用缓冲技术来提高对磁盘的访问速度。

内核将磁盘上的数据复制到内核缓冲区中，当一个用户空间中的进程要从磁盘上读取数据时，内核一般不直接读磁盘，而是将内核缓冲区中的数据复制到进程缓冲区中。
当进程所要求的数据块不在内核缓冲区时，内核会把相应的数据块加入到请求数据列表中，然后把该进程挂起，接着为其他进程服务。
一段时间之后(很短)，内核把相应的数据块从磁盘读到内核缓冲区，然后再把数据复制到进程缓冲区中，最后唤醒被挂起的进程。

理解内核缓冲技术的原理有助于更好的掌握系统调用 read 和 write , read 把数据从内核缓冲区复制到进程缓冲区，write 把数据从进程缓冲区复制到内核缓冲区，它们并不等价于数据在内核缓冲和磁盘之间的交换。
从理论上讲，内核可以在任何时候写磁盘，但并不是所有的 write 操作都会导致内核写动作。内核会把要写的数据暂时存放在缓冲区中，积累到一定数量后再一次写入。有时会导致意外，如断电，内核来不及将内核缓冲区的数据写到磁盘上，数据会丢失。
```
应用内核缓冲技术导致的结果：
- 提高磁盘 I/O 效率
- 优化磁盘的写操作
- 需要及时地将缓冲数据写入磁盘


### 2.9.3 改变文件的当前未知
- Unix 每次打开一个文件都会保存一个指针来记录文件的当前位置
- 当从文件读取数据时，内核从指针表明的地方开始，读取指针的位置，然后移动指针，指向下一个未被读取的字节，写文件的操作类似。
- 指针时与文件描述符相关联的，而不是与文件关联，所以如果两个程序同时打开一个文件，会有两个指针，两个程序对文件的读操作不会相互干扰。


### 3.4.1 目录
- 目录是一种特殊的文件，它的内容是文件和目录的名字。他们包含很多条记录，每个记录的格式统一标准定义。每条记录的内容代表一个文件或目录。
- 目录永远不会空，至少包含"." 或者 ".."

### 3.6.6 将模式字段转换为字符
- st_mode 是一个 16 位的二进制数
- 前四位用作文件类型，最后可表示 16 种类型，目前使用七种
- 接下来 3 位是文件的特殊属性；1 表示有，0 表示没有；分别位 set-user-ID、set-group-ID、sticky  
- 最后 9 位，3 个为一组，即表示所有者、同组用户、其他用户的读、写、执行权限
```
 子域编码是系统编程的一种重要的概念
 掩码的概念：将不需要的字段置为0 ，需要的字段的值不发生改变
```

### 3.7.3 sticky 位
- sticky 位对于文件和目录有不同的用途
- 从交换分区装载程序要比普通的硬盘空间快，在非交换分区的硬盘上，程序可能被分成好几块分别存放在多个地方，交换空间上的文件是不分块的
- sticky 位告诉内核即使没有人使用程序，也要把他放在交换空间中; 现在虚拟内存取代了交换技术，可以以更小的单位 page 进行交换
- 对于目录而言，sticky 的含义不同，sticky 位保证目录里面的文件只能被创建者删除

### 3.9.1 文件类型
- 文件类型是在创建文件的时候建立的，不同文件使用不同的函数创建
- 文件一经创建，类型就无法修改

### 4.3 Unix 文件系统的内部结构
- 第一层抽象：从铺盘到分区
- 第二场抽象：从磁盘到块序列
- 第三层抽象：从块序列到三个区域的划分
```
为了将不同类型的数据存储在被编号的磁盘快上，Unix 将这些磁盘分成 超级块、i-节点表、数据区。      
数据区，用来存放文件内容；i-节点用来存放文件属性；超级块，用来存放文件系统本身的信息。 
文件系统由这三部分组成，其中任一部分都是由很多有序磁盘快组成。
```

### 4.3.4 创建一个文件的过程
1. 文件属性的存储：内核找到 i-节点，内核把文件的信息记录其中
2. 文件内容的存储：计算文件需要的磁盘块，内核从自由块的列表中找出需要的磁盘块，内核缓冲区将数据复制到磁盘块
3. i-节点记录对应文件内容存储的磁盘块
4. 内核将 i-节点 和 文件名的对应关系添加到目录

### 4.5.1 pwd 的工作过程
- 在一个 Unix 文件系统的根目录中，'.' 和 '..'  指向同一个 i-节点
- Unix 允许将一个磁盘的存储组织成一颗由多棵树相互连接的树。每个磁盘或磁盘上的分区都包含一颗目录树

### 4.6 多个文件系统组合
- 每个分区有自己的文件系统树。当计算机上由多余一个文件系统时，Unix 提供一种方法将这些树整合成大树
- 装载文件系统：子树的根目录被嵌入到根文件系统的一个目录中，子树所在的目录被称做第二个系统的装载点

### 5.2 设备就像文件
- 在 Unix 系统中，每个设备都被当作一个文件。每个设备都有一个文件名、一个 i-节点、一个文件所有者、一个权限位的集合和最近修改时间。和文件有关的所有内容都被运用于终端和其他设备
- 设备支持与所有文件相关的系统调用：open, read, write ,lseek, close ,stat
- 终端支持 read ，write ，但不支持 lseek 

### 5.2.4 设备文件属性
- 设备文件的i-节点存储的是指向内核子程序的指针，而不是文件大学和存储列表。内核中传输设备数据的子程序称为设备驱动程序
- 主设备号确定处理该设备实际的子程序，而从设备号被作为参数传输到子程序
- i-节点的类型被记录在结构stat 的成员变量st_mode的类型区域中
- 磁盘文件的i-节点包含指向数据块的指针。设备文件的i-节点用于告诉内核文件的类型。如果是磁盘文件，那么内核通过访问块分配表来读取数据。如果文件是设备文件，那么内核通过调用该设备驱动程序的read 来读取数据。open,write,lseek,close 类似

### 5.4 磁盘连接的属性
连接即：文件描述符的属性
1. 属性1: 缓冲 
```
系统调用：fcntl()
缓冲机制操作位: O_SYNC 
int s;                         //settings
s = fcntl(fd,F_GETFL);         //get flags
s |= O_SYNC;                   //set SYNC bit
result = fcntl(fd,F_SETFL,s);  //set flags
if (result ==1)                //if error
    perror("setting SYNC");    //report
```
2. 属性2：自动添加模式
```
自动添加属性对于若干个进程在同一时间写入文件很有用
操作位： O_APPEND
int s;                         //settings
s = fcntl(fd,F_GETFL);         //get flags
s |= O_APPEND;                   //set APPEND bit
result = fcntl(fd,F_SETFL,s);  //set flags
if (result ==1)                //if error
    perror("setting APPEND");  //report
else 
    write(fd,&rec,1);          //write record at end
当 O_APPEND 被置位时，内核将lseek和write合成一个原子操作，被连接成一个不可分割的单元

以下两个调用是等价的：
fd = creat(filename, permission_bits);
fd = open(filename,O_CREAT | O_TRUNC | O_WRONLY ,permission_bits)
```

### 5.5 终端连接的属性
1. stty 命令让用户读取和修改终端驱动程序的设置
```
库函数 tcgetattr 和 tcsetattr 提供对终端驱动程序的访问。两个函数在 termios 结构中交换设置。
int result = tcsetattr(int fd ,int when, struct termios *info)
when:
TCSANOW - 立即更新驱动程序设置
TCSADRAIN - 等待直到驱动程序队列中的所有输出都被传送到终端。然后进行驱动程序的更新。
TCSAFLUSH - 等待直到驱动程序队列中的所有输出都被传送出去。然后释放所有队列中的输入数据，并进行一定的变化
```

### 5.5.6 编写终端驱动程序：关于位
```
测试位： if(flagset & MASK) ... 
置位：   flagset |= MASK
清楚位： flagset & = ~MASK
```

### 5.6 其他设备编程：ioctl
- 系统调用 ioctl 提供对连接到 fd 的设备驱动程序的属性和操作的访问。每种设备都有自己的属性集和ioctl 操作集
```
int result = ioctl(int fd ,int operation,[arg...]);
阅读头文件是了解设备类型以及相关函数的好方法
```
### 5.7 文件、设备、流
- 任何数据的源和目的地都被 Unix 视为文件
- 基本的系统调用既适用于磁盘文件也适用于设备文件，它们的区别体现在对连接的操作上
- 流模型的一个重要特征是处理的模块化 treamio 





####  基础命令的实现
- who , 读取 /var/adu/utmp
- ls  , opendir -> readdir -> closedir ; readdir  -> stat(file)

链接：一个链接是指向文件的指针，软链接指向inode ，硬链接是指向 block。

block：存放文件
inode： 存放文件属性
superblock： 用来存放文件系统本身的信息

创建文件的过程：inode 存储文件属性 -> free block 存储数据 ->  inode 记录 block -> 添加文件名到目录(文件名和inode 节点的关系)

- pwd ， 查找每一层的 "." ，然后在每一层的父目录中查找 i-节点名字，直到树的顶端。

